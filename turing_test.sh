#!/usr/bin/env bash

# Create a temp file to store the output of the tmux pane
input=$(mktemp)
output=$(mktemp)
attack_file=attack_file
truncate -s 0 $attack_file

gpt4=0
while getopts ":f" opt; do
    case $opt in
	f)
	    gpt4=1
	    ;;
	\?)
	    echo "Invalid option: -$OPTARG" >&2
	    exit 1
	    ;;
	:)
	    echo "Option -$OPTARG requires an argument." >&2
	    exit 1
	    ;;
    esac
done
shift $((OPTIND-1))

if [[ $gpt4 -eq 1 ]]; then
    echo "Using GPT-4"
    chatgpt="chatgpt --model gpt-4"
else
    chatgpt="chatgpt"
fi

# new tmux session for turing test (we do this since otherwise the command line
# CLI doesn't have nice terminator strings)
tmux new-session -d -s turing_test

# pipe the output of tmux pane to the output pipe
tmux pipe-pane -Oo -t turing_test:0.0 "cat > $output"

# start a program which echos back out the input in the background, and
# redirect the input and output to the pipes
tmux send-keys -t turing_test:0.0 "chatgpt" C-m

# read the output until you see "Enter a prompt:" and then stop
next_prompt () {
	get_out=0
	while true; do
	    read line
	    if [[ $line != "" ]]; then
		echo $line
	    fi
	    if [[ $line == *"Enter a prompt:"* ]]; then
		truncate -s 0 $output
		break
	    fi
	done < $output
}
next_prompt

## Read in the file provided in the first argument
while read line; do
    if [[ $line == @PROGRAM* ]]; then
	program=$(echo $line | cut -d' ' -f2)
	# a relative path name to the program to be tested from the directory of the first command line argument
	program=$(dirname $1)/$program
    fi
    # next, look for the @INPUT tag. Scan this input into a variable until an @END tag is found
    if [[ $line == @INPUT* ]]; then
	inputstr=""
	while read line; do
	    if [[ $line == @END* ]]; then
		break
	    fi
	    # send raw characters for $line (no interpretation of escape characters)
	    inputstr="$inputstr$line "
	done
	inputstr=${inputstr/;/\\;}
	tmux send-keys -t turing_test:0.0 "$inputstr" C-m

	next_prompt
    fi
done < $1

tmux kill-session -t turing_test
rm $output
